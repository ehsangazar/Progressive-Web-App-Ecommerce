"use strict";

exports.__esModule = true;
exports.default = plugin;

var _generator = _interopRequireDefault(require("@babel/generator"));

var _traverse = require("@babel/traverse");

var _commonTags = require("common-tags");

var _fsExtra = require("fs-extra");

var _defaults = _interopRequireDefault(require("lodash/defaults"));

var _cssProp = _interopRequireDefault(require("./features/css-prop"));

var _styledComponent = _interopRequireDefault(require("./features/styled-component"));

var _stylesheet = _interopRequireDefault(require("./features/stylesheet"));

var _Symbols = require("./utils/Symbols");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function plugin() {
  return {
    pre(file) {
      file.set(_Symbols.IMPORTS, []);

      if (!file.has(_Symbols.STYLES)) {
        file.set(_Symbols.STYLES, {
          id: 0,
          changeset: [],
          styles: new Map()
        });
      }

      if (!file.has(_Symbols.COMPONENTS)) {
        file.set(_Symbols.COMPONENTS, new Map());
      }
    },

    post(file) {
      const {
        opts
      } = this;
      let {
        styles,
        changeset
      } = file.get(_Symbols.STYLES);
      const importNodes = file.get(_Symbols.IMPORTS);
      importNodes.forEach(path => {
        const decl = !path.isImportDeclaration() ? path.findParent(p => p.isImportDeclaration()) : path;
        if (!decl) return;
        const {
          start,
          end
        } = decl.node;
        path.remove();
        if (opts.generateInterpolations) changeset.push({
          start,
          end,
          // if the path is just a removed specifier we need to regenerate
          // the import statement otherwise we remove the entire declaration
          code: !path.isImportDeclaration() ? (0, _generator.default)(decl.node).code : ''
        });
      });
      styles = Array.from(styles.values());
      changeset = changeset.concat(styles);
      file.metadata.astroturf = {
        styles,
        changeset
      };

      if (opts.writeFiles !== false) {
        styles.forEach(({
          absoluteFilePath,
          value
        }) => {
          (0, _fsExtra.outputFileSync)(absoluteFilePath, (0, _commonTags.stripIndent)([value]));
        });
      }
    },

    visitor: _traverse.visitors.merge([{
      Program: {
        enter(_, state) {
          state.defaultedOptions = (0, _defaults.default)(state.opts, {
            tagName: 'css',
            allowGlobal: true,
            styledTag: 'styled',
            customCssProperties: 'cssProp' // or: true, false

          });
        }

      },
      ImportDeclaration: {
        exit(path, state) {
          const {
            tagName
          } = state.defaultedOptions;
          const specifiers = path.get('specifiers');
          const tagImport = path.get('specifiers').find(p => p.isImportSpecifier() && p.node.imported.name === 'css' && p.node.local.name === tagName);

          if (tagImport) {
            state.file.get(_Symbols.IMPORTS).push(specifiers.length === 1 ? path : tagImport);
          }
        }

      }
    }, _cssProp.default, _styledComponent.default, _stylesheet.default])
  };
}